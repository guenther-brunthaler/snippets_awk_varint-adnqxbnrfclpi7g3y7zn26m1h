#! /bin/sh
set -e
test 'test $? = 0 || echo "$0 failed!" >& 2'
awk -f - -- "$@" << EOF && exit || false || exit
	function vinternal() {
		for (vmodulus= 1; vmodulus + 1 > vmodulus; ) {
			vmodulus+= vmodulus
		}
		vmodulus*= 0.5 # First bit is only implicit.
	}

	function vinit(v, uint    , n) {
		if (!vmodulus) vinternal()
		if ((n= v["n"]) > 1) {
			for (;;) {
				delete v[--n]
				if (n == 1) break
			}
		}
		v["n"]= 1
		v[0]= uint
	}
	
	function vdump(v    , i, n) {
		n= v["n"]
		for (i= 0; i < n; ++i) printf "[%u]= %.0f\n", i, v[i]
	}
	
	function vassign(dst, src    , i, ns, nd) {
		nd= dst["n"]; ns= src["n"]
		for (i= 0; i < ns; ++i) dst[i]= src[i]
		while (i < nd) delete dst[i++]
		dst["n"]= ns
	}

	function vadd(dst, add    , i, ns, nd, sum, carry) {
		if ((ns= add["n"]) > (nd= dst["n"])) dst["n"]= nd= ns
		for (carry= i= 0; i < nd; ++i) {
			if ( \
				carry= (sum= dst[i] + add[i] + carry) \
					>= vmodulus \
			) { \
				sum-= vmodulus
			}
			dst[i]= sum
		}
		if (carry) {
			dst[nd]= 1
			dst["n"]= nd + 1
		}
	}

	function vmodsum(dst, add, mod    , i, n, sum, carry, borrow) {
		if (src["n"] > (n= mod["n"])) n= src["n"]
		if (n > dst["n"]) dst["n"]= n; else n= dst["n"]
		#print "n= " n
		for (carry= borrow= i= 0; i < n; ++i) {
			#printf "add dst[%u] + src[%u] + carry" \
			#	" == %.0f + %.0f + %u\n" \
			#	, i, i, dst[i], add[i], carry
			sum= dst[i] + add[i] + carry
			#printf "sum = %.0f\n", sum
			if (carry= sum >= vmodulus) {
				sum-= vmodulus
			#	printf "reduce to %.0f, carry= %u\n" \
			#		, sum, carry
			}
			dst[i]= sum
			borrow= (sum-= mod[i] - borrow) < 0;
		}
		if (!borrow) {
			for (borrow= i= 0; i < n; ++i) {
				#printf "add dst[%u] + src[%u] + carry" \
				#	" == %.0f + %.0f + %u\n" \
				#	, i, i, dst[i], add[i], carry
				#printf "sum = %.0f\n", sum
				borrow= (sum= dst[i] - mod[i] - borrow) < 0;
				if (borrow) {
					sum+= vmodulus
				#	printf "reduce to %.0f, carry= %u\n" \
				#		, sum, carry
				}
				dst[i]= sum
			}
		}
	}
	
	function vnormalize(v    , n, i) {
		i= n= v["n"]
		while (i > 0 && v[i - 1] == 0) delete v[--i]
		if (i < n) v["n"]= i
	}
	
	function v2str(v    , vn, i, j, k, n, o, b, carry, sum) {
		vnormalize(v); vn= v["n"]
		n= 0; o[n++]= 0
		for (i= vn; i--; ) {
			b= v[i]
			for (j= vmodulus; (j*= 0.5) >= 1; ) {
				if (carry= b >= j) b-= j
				for (k= 0; k < n; ++k) {
					sum= o[k]
					if (carry= (sum+= sum + carry) >= 10) {
						sum-= 10
					}
					o[k]= sum
				}
				if (carry) o[n++]= 1
			}
		}
		sum= ""
		for (k= n; k--; ) sum= sum o[k]
		return sum
	}

	function vstr2v(dst, str    , i, sl, c, a) {
		sl= length(str)
		vinit(dst, 0)
		for (i= 1; i <= sl; ++i) {
			if ((c= substr(str, i, 1)) < "0" || c > "9") {
				die("Invalid digit '" c "' in '" str "'!")
			}
			vassign(a, dst); vadd(a, a); vadd(a, a)
			vadd(dst, a); vadd(dst, dst)
			vinit(a, c + 0)
			vadd(dst, a)
		}
	}

	function vfib(v, n    , i, u, t) {
		if (n <= 1) {
			vinit(v, n)
			return
		}
		vinit(u, i= 0); vinit(v, ++i)
		for ( ; i < n; ++i) {
			vassign(t, v)
			vadd(v, u)
			vassign(u, t)
		}
	}

	function die(msg) {
		print msg > "/dev/stderr"
		exit 1
	}

	BEGIN {
		if (ARGC != 2) exit 1
		n= ARGV[1]
		vstr2v(v, n)
		print v2str(v)
		exit
		if (n < 0 || n != int(n)) die("Invalid argument!")
		vfib(v, n)
		#vinit(v, 1)
		#for (i= 1; i < n; ++i) {
		#	print i ":"
		#	vadd(v, v)
			vdump(v)
		#	print
		#}
		print "fib(" n ")= " v2str(v)
	}
EOF
