#! /bin/sh
set -e
test 'test $? = 0 || echo "$0 failed!" >& 2'
awk -f - -- "$@" << EOF && exit || false || exit
	function vinternal() {
		for (vmodulus= 1; vmodulus + 1 > vmodulus; ) {
			vmodulus+= vmodulus
		}
		vmodulus*= 0.5 # First bit is only implicit.
	}

	function vinit(v, uint    , i) {
		if (!vmodulus) vinternal()
		for (i in v) delete v[i]
		v["n"]= 1
		v[0]= uint
	}
	
	function vdump(v    , i, n) {
		n= v["n"]
		for (i= 0; i < n; ++i) printf "[%u]= %.0f\n", i, v[i]
	}
	
	function vassign(dst, src    , i, ns, nd) {
		nd= dst["n"]; ns= src["n"]
		for (i= 0; i < ns; ++i) dst[i]= src[i]
		while (i < nd) delete dst[i++]
		dst["n"]= ns
	}

	function vadd(dst, add    , i, n, sum, carry) {
		if (add["n"] > (n= dst["n"])) dst["n"]= n= add["n"]
		for (carry= i= 0; i < n; ++i) {
			if ( \
				carry= (sum= dst[i] + add[i] + carry) \
					>= vmodulus \
			) { \
				sum-= vmodulus
			}
			dst[i]= sum
		}
		if (carry) {
			dst[n]= 1
			dst["n"]= n + 1
		}
	}

	# Use the schoolbook method because Karatsuba is only faster for 320+
	# bit numbers, and we want to work with just 130 bit numbers
	# eventually.
	function vmult(dst, mult    , add, i, j, n, b, b0) {
		vinit(add); vassign(add, dst); vinit(dst, 0);
		vnormalize(mult); n= mult["n"]
		for (i= 0; i < n; ++i) {
			b= mult[i]
			for (j= 1; j < vmodulus; j+= j) {
				b0= b * 0.5
				if ((b= int(b0)) != b0) {
					vadd(dst, add)
					if (!b && i + 1 == n) break
				}
				vadd(add, add)
			}
		}
	}

	# <dst> as well as <add> must be less than <mod>.
	function vmodsum(dst, add, mod    , i, n, sum, carry, borrow) {
		if (src["n"] > (n= mod["n"])) n= src["n"]
		if (n > dst["n"]) dst["n"]= n; else n= dst["n"]
		for (carry= borrow= i= 0; i < n; ++i) {
			if ( \
				carry= (sum= dst[i] + add[i] + carry) \
				>= vmodulus \
			) {
				sum-= vmodulus
			}
			dst[i]= sum
			borrow= (sum-= mod[i] - borrow) < 0;
		}
		if (!borrow) {
			for (borrow= i= 0; i < n; ++i) {
				if ( \
					borrow \
					= (sum= dst[i] - mod[i] - borrow) < 0 \
				) {
					sum+= vmodulus
				}
				dst[i]= sum
			}
		}
	}

	# <dst> as well as <mult> must be less than <mod>.
	function vmodmult(dst, mult, mod    , add, i, j, n, b, b0) {
		vinit(add); vassign(add, dst); vinit(dst, 0);
		vnormalize(mult); n= mult["n"]
		for (i= 0; i < n; ++i) {
			b= mult[i]
			for (j= 1; j < vmodulus; j+= j) {
				b0= b * 0.5
				if ((b= int(b0)) != b0) {
					vmodsum(dst, add, mod)
					if (!b && i + 1 == n) break
				}
				vmodsum(add, add, mod)
			}
		}
	}

	
	function vnormalize(v    , n, i) {
		i= n= v["n"]
		while (i > 0 && v[i - 1] == 0) delete v[--i]
		if (i < n) v["n"]= i
	}
	
	function v2str(v    , vn, i, j, k, n, o, b, carry, sum) {
		vnormalize(v); vn= v["n"]
		n= 0; o[n++]= 0
		for (i= vn; i--; ) {
			b= v[i]
			for (j= vmodulus; (j*= 0.5) >= 1; ) {
				if (carry= b >= j) b-= j
				for (k= 0; k < n; ++k) {
					sum= o[k]
					if (carry= (sum+= sum + carry) >= 10) {
						sum-= 10
					}
					o[k]= sum
				}
				if (carry) o[n++]= 1
			}
		}
		sum= ""
		for (k= n; k--; ) sum= sum o[k]
		return sum
	}

	function vstr2v(dst, str    , i, sl, c, a) {
		sl= length(str)
		vinit(dst, 0)
		for (i= 1; i <= sl; ++i) {
			if ((c= substr(str, i, 1)) < "0" || c > "9") {
				die("Invalid digit '" c "' in '" str "'!")
			}
			vassign(a, dst); vadd(a, a); vadd(a, a)
			vadd(dst, a); vadd(dst, dst)
			vinit(a, c + 0)
			vadd(dst, a)
		}
	}

	function die(msg) {
		print msg > "/dev/stderr"
		exit 1
	}

	BEGIN {
		if (ARGC < 3) {
			die( \
				"Specify modulus fist, then the numbers to" \
				" add modulo that modulus!" \
			)
		}
		vstr2v(mod, ARGV[1])
		vinit(prod, 1)
		for (i= 2; i < ARGC; ++i) {
			vstr2v(mult, ARGV[i])
			vmodmult(prod, mult, mod)
		}
		print "product = " v2str(prod)
	}
EOF
